
## @param s A n x s stratum membership matrix
## @param sn A s-vector of units per stratum
## @param sn1 A s-vector of treated units per stratum
## @return A matrix of treatment assignments at the unit level
design_to_zs <- function(s, sn, sn1) {

    ## generate all possible randomizations
    zs_by_strata <- mapply(sn, sn1, FUN = function(n, n1) {
        apply(combn(n, n1), 2, function(idx) {
            zz <- numeric(n)
            zz[idx] <- 1
            return(zz)
        })
    }, SIMPLIFY = FALSE)

    zj <- sapply(zs_by_strata, ncol)
    idxes <- as.matrix(do.call(expand.grid, lapply(zj, function(k) { 1:k })))
    zs <- apply(idxes, 1, function(idx) {
        unlist(mapply(idx, zs_by_strata, FUN = function(a, b) { b[, a] }))})

    return(zs)
}

## @param z treatment assignment
## @param x data matrix as generated by model.matrix, e.g.
## @param s strata matrix as generated by model.matrix(~ match - 1, data = df)
## @param sn units per strata ec, 
empirical_euclidean <- function(x, s, sn, sn1) {

    ## strata level probabilities
    p <- sn1 / sn

    ## J = Z - E(Z)
    ZtoJ <- function(z) { (z - s %*% p)  }

    ## Compute the Mahalanobis distance
    meat <- x %*% t(x)
    mahal <- function(z) {
        j <- ZtoJ(z)
        (t(j) %*% meat %*% j)[1,1]
    }

    zs <- design_to_zs(s, sn, sn1)

    ms <- apply(zs, 2, mahal)

    return(ms)
}

## @param z treatment assignment
## @param x data matrix as generated by model.matrix, e.g.
## @param s strata matrix as generated by model.matrix(~ match - 1, data = df)
## @param sn units per strata ec, 
empirical_mahalanobis <- function(x, s, sn, sn1) {
    sn0 <- sn - sn1

    ## strata level probabilities
    p <- sn1 / sn # pi

    ## The E(JJ') matrix
    k <- length(sn)
    Gamma <- as.matrix(s %*% diag((p * (sn1 - 1) / (sn - 1) - p^2) , ncol = k, nrow = k)  %*% t(s))
    diag(Gamma) <- as.vector(s %*% (p * (1 - p) ))

    ## meat in the J' a J sandwich
    rotated <- x %*% XtX_pseudoinv_sqrt(t(x) %*% Gamma %*% x, TRUE) 

    empirical_euclidean(rotated, s, sn, sn1)
}


## @param z treatment assignment
## @param x data matrix as generated by model.matrix, e.g.
## @param s strata matrix as generated by model.matrix(~ match - 1, data = df)
## @param sn units per strata ec, 
empirical_t2 <- function(x, s, sn, sn1) {
    sn0 <- sn - sn1

    zs <- design_to_zs(s, sn, sn1)
    k <- dim(zs)[2]

    ## strata level probabilities
    p <- sn1 / sn # pi

    ZtoJ <- function(z) { (z - s %*% p)  }

    ## Compute the Mahalanobis distance
    xj <- function(z) {
        j <- ZtoJ(z)
        as.matrix(t(x) %*% j)
    }

    xjs <- apply(zs, 2, xj)

    cov_xj <- (k - 1) / k * cov(t(xjs))

    cov_xj_inv_sq <- XtX_pseudoinv_sqrt(cov_xj, TRUE)

    tmaker <- function(z) {
        j <- ZtoJ(z)
        as.matrix(t(x %*% cov_xj_inv_sq) %*% j)
    }

    ts <- apply(zs, 2, tmaker)

    return(ts^2)
}

## @param z treatment assignment
## @param x data matrix as generated by model.matrix, e.g.
## @param s strata matrix as generated by model.matrix(~ match - 1, data = df)
## @param sn units per strata ec, 
empirical_S2 <- function(x, s, sn, sn1) {
    sn0 <- sn - sn1

    zs <- design_to_zs(s, sn, sn1)
    k <- dim(zs)[2]

    ## strata level probabilities
    p <- sn1 / sn # pi

    ZtoJ <- function(z) { (z - s %*% p)  }

    tmaker <- function(z) {
        j <- ZtoJ(z)
        as.matrix(t(x) %*% j)
    }

    ts <- apply(zs, 2, tmaker)

    return(ts^2)
}


empirical_S_by_strata <- function(f, treated,  x) {
    design <- create_stratified_design(f, treated = treated)

    by_s <- lapply(levels(f), function(s) {
        idx <- f == s
        sr <- x[idx, ]
        n <- dim(sr)[1]
        n1 <- treated[s]

        ts <- apply(combn(n, n1), 2, function(idx) {
            z <- numeric(n)
            z[idx] <- 1
            j <- (z - n1/n )
            t(sr) %*% j
        })

        ts
    })

}

empirical_cov <- function(x, s, sn, sn1) {
    sn0 <- sn - sn1

    zs <- design_to_zs(s, sn, sn1)
    k <- dim(zs)[2]

    ## strata level probabilities
    p <- sn1 / sn # pi

    ## j = Z - E(Z)
    ZtoJ <- function(z) { (z - s %*% p) }

    ## Compute the Mahalanobis distance
    xj <- function(z) {
        j <- ZtoJ(z)
        as.matrix(t(x) %*% j)
    }

    xjs <- apply(zs, 2, xj)

    cov_xj <- (k - 1) / k * cov(t(xjs))

    return(cov_xj)
}
