library('testthat')
library(MASS)
context('Moment Calculation')

## @param s A n x s stratum membership matrix
## @param sn A s-vector of units per stratum
## @param sn1 A s-vector of treated units per stratum
## @return A matrix of treatment assignments at the unit level
design_to_zs <- function(s, sn, sn1) {

    ## generate all possible randomizations
    zs_by_strata <- mapply(sn, sn1, FUN = function(n, n1) {
        apply(combn(n, n1), 2, function(idx) {
            zz <- numeric(n)
            zz[idx] <- 1
            return(zz)
        })
    }, SIMPLIFY = FALSE)

    zj <- sapply(zs_by_strata, ncol)
    idxes <- as.matrix(do.call(expand.grid, lapply(zj, function(k) { 1:k })))
    zs <- apply(idxes, 1, function(idx) {
        unlist(mapply(idx, zs_by_strata, FUN = function(a, b) { b[, a] }))})

    return(zs)
}

## @param z treatment assignment
## @param x data matrix as generated by model.matrix, e.g.
## @param s strata matrix as generated by model.matrix(~ match - 1, data = df)
## @param sn units per strata ec, 
empirical_mahalanobis <- function(x, s, sn, sn1) {
    sn0 <- sn - sn1

    ## strata level probabilities
    p <- sn1 / sn # pi
    one_p <- sn0 / sn # 1 - pi
    p_one_p <- p * one_p # pi (1 - pi)

    ## The E(JJ') matrix
    k <- length(sn)
    Gamma <- as.matrix(s %*% diag((p * (sn1 - 1) / (sn - 1) - p^2) / p^2 , ncol = k, nrow = k)  %*% t(s))
    diag(Gamma) <-  as.vector(s %*% ((1 - p) / p))

    ## meat in the J' a J sandwich
    meat <- x %*% ginv(t(x) %*% Gamma %*% x) %*% t(x)

    ZtoJ <- function(z) { (z - s %*% p) / (s %*% p) }

    ## Compute the Mahalanobis distance
    mahal <- function(z) {
        j <- ZtoJ(z)
        (t(j) %*% meat %*% j)[1,1]
    }

    zs <- design_to_zs(s, sn, sn1)

    ms <- apply(zs, 2, mahal)

    return(ms)
}


## @param z treatment assignment
## @param x data matrix as generated by model.matrix, e.g.
## @param s strata matrix as generated by model.matrix(~ match - 1, data = df)
## @param sn units per strata ec, 
empirical_t2 <- function(x, s, sn, sn1) {
    sn0 <- sn - sn1

    zs <- design_to_zs(s, sn, sn1)
    k <- dim(zs)[2]

    ## strata level probabilities
    p <- sn1 / sn # pi

    ZtoJ <- function(z) { (z - s %*% p) / (s %*% p) }

    ## Compute the Mahalanobis distance
    xj <- function(z) {
        j <- ZtoJ(z)
        t(x) %*% j
    }

    xjs <- apply(zs, 2, xj)

    cov_xj <- (k - 1) / k * cov(t(xjs))

    cov_xj_inv_sq <- XtX_pseudoinv_sqrt(cov_xj, TRUE)

    tmaker <- function(z) {
        j <- ZtoJ(z)
        t(x %*% cov_xj_inv_sq) %*% j
    }

    ts <- apply(zs, 2, tmaker)

    return(ts^2)
}

empirical_ts_by_strata <- function(f, treated,  x) {
    design <- create_stratified_design(f, treated = treated)

    rotated <- rotate_covariates(design, x)

    by_s <- lapply(levels(f), function(s) {
        idx <- f == s
        sr <- rotated[idx, ]
        n <- dim(sr)[1]
        n1 <- treated[s]

        ts <- apply(combn(n, n1), 2, function(idx) {
            z <- numeric(n)
            z[idx] <- 1
            j <- (z - n1/n )  / (n1/n)
            t(sr) %*% j
        })

        ts
    })

}

test_that("Set up code agrees with itself", {

    ## Set up
    ## Generate some random data
    set.seed(30303)
    n <- 12
    x1 <- rnorm(n)
    x2 <- x1 + runif(n, -1,  3)
    x3 <- sample(letters[1:3], n, replace = TRUE )
    df <- data.frame(x1, x2, x3)
    df <- df[order(x1), ]
    df$match <- as.factor(
        c(1, 1, 1, 1, 1,
          2, 2, 2, 2, 2, 2, 2))
    df$z <- c(1, 0,
              0, 1,
              0, 1, 0,
              0, 1, 0, 1, 1)
    ## end data set up

    x <- model.matrix(~ x1 + x2 + x3 - 1, data = df)

    d <- create_stratified_design(df$match, z = df$z)

    emp_t2 <- empirical_t2(x, d@Units, d@Count, d@Treated)
    expect_equal(dim(emp_t2), c(4, 350))

    emp_t2_sums <- colSums(emp_t2)
    expect_equal(mean(emp_t2_sums), 4)

    emp_mal <- empirical_mahalanobis(x, as.matrix(d@Units), d@Count, d@Treated)

    expect_equivalent(emp_t2_sums, emp_mal)

    ## explicit strata level T_k's
    es_t <- empirical_ts_by_strata(df$match, c("1" = 2, "2" = 4), x)
    indexes <- lapply(es_t, function(x) { 1:dim(x)[2] })
    grd <- as.matrix(do.call(expand.grid, indexes))

    es_t_t <- apply(grd, 1, function(ab) {
        es_t[[1]][, ab[1]] + es_t[[2]][, ab[2]]
    })

    es_t_t2 <- es_t_t^2
    es_t_m <- colSums(es_t_t2)
    expect_equal(mean(es_t_m), 4)
    expect_equal(var(es_t_m), var(emp_mal))

    expect_equivalent(sort(es_t_m), sort(emp_mal))
})

test_that("Calculating moments of Mahalanobis statistic", {
    library(MASS)

    ### Set up
    ## Generate some random data
    set.seed(30303)
    n <- 12
    x1 <- rnorm(n)
    x2 <- x1 + runif(n, -1,  3)
    x3 <- sample(letters[1:3], n, replace = TRUE )
    df <- data.frame(x1, x2, x3)
    df <- df[order(x1), ]
    df$match <- as.factor(
        c(1, 1,
          2, 2,
          3, 3, 3,
          4, 4, 4, 4, 4))
    df$z <- c(1, 0,
              0, 1,
              0, 1, 0,
              0, 1, 0, 1, 1)

    ### end data set up
    x <- model.matrix(~ x1 + x2 + x3 - 1, data = df)
    s <- model.matrix(~ match - 1, data = df)

    ## set up some matrices to indicate strata level stuff
    sn <- as.vector(t(s) %*% rep(1, n))
    sn1 <- as.vector(t(s) %*% df$z)
    sn0 <- sn - sn1

    ## assumes X is in strata sorted order
    zs <- design_to_zs(s, sn, sn1)

    ref_xb_chisquare <- xBalance(z ~ x1 + x2 + x3, data = df, strata = list(a = ~ match), report = 'all')$overall$chisquare

    ms <- empirical_mahalanobis(x, s, sn, sn1)
    expect_equal(mean(ms), 4)

    xbs <- apply(zs, 2, function(z) {
        tmp <- df
        tmp$z <- z
        xb <- xBalance(z ~ x1 + x2 + x3, data = tmp, strata = list(a = ~ match), report = 'all')
        xb$overall$chisquare
    })

    expect_equal(mean(xbs), 4)

    expect_true(all((ms - xbs)^2 <= sqrt(.Machine$double.eps)))


    bts <- apply(zs, 2, function(z) {
        tmp <-df
        tmp$z <- z
        bt <- balanceTest(z ~ x1 + x2 + x3 + strata(match), data = tmp, report = 'all')$overall[1,1]
    })

    expect_equal(mean(bts), 4)

    expect_true(all((ms - bts)^2 <= sqrt(.Machine$double.eps)))
    expect_true(all((xbs - bts)^2 <= sqrt(.Machine$double.eps)))
})

test_that("Direct moment calculations are correct", {
    

### Set up
    ## Generate some random data
    set.seed(30303)
    n <- 12
    x1 <- rnorm(n)
    x2 <- x1 + runif(n, -1,  3)
    x3 <- sample(letters[1:3], n, replace = TRUE )
    df <- data.frame(x1, x2, x3)
    df <- df[order(x1), ]
    df$match <- as.factor(
        c(1, 1,
          2, 2,
          3, 3, 3,
          4, 4, 4, 4, 4))
    df$z <- c(1, 0,
              0, 1,
              0, 1, 0,
              0, 1, 0, 1, 1)

### end data set up
    x <- model.matrix(~ x1 + x2 + x3 - 1, data = df)
    s <- model.matrix(~ match - 1, data = df)

    ## set up some matrices to indicate strata level stuff
    sn <- as.vector(t(s) %*% rep(1, n))
    sn1 <- as.vector(t(s) %*% df$z)
    sn0 <- sn - sn1

    ## assumes X is in strata sorted order
    zs <- design_to_zs(s, sn, sn1)

    ### this is largely taken from balanceTest
    fmla <- z ~ x1 + x2 + x3 + strata(match) - 1
    df$`(weights)` <- 1
    design <- makeDesigns(fmla, df)
    aggDesign       <- aggregateDesigns(design)
    aligned <- alignDesignsByStrata(aggDesign)$match

    ## lets double check that we are aligned
    xbar_s <- t(s) %*% x / sn
    xaligned <- x - s %*% xbar_s

    expect_true(all((xaligned - aligned@Covariates[, 1:5])^2 <= sqrt(.Machine$double.eps)))

    ms <- empirical_mahalanobis(x, s, sn, sn1)
    ms_aligned <- empirical_mahalanobis(x, s, sn, sn1)
    expect_true(all(ms == ms_aligned))



})


test_that("Single strata covariance calculations", {
    

    ## Set up
    ## Generate some random data
    ## only one stratum
    set.seed(30303)
    n <- 12
    x1 <- rnorm(n)
    x2 <- x1 + runif(n, -1,  3)
    x3 <- sample(letters[1:3], n, replace = TRUE )
    df <- data.frame(x1, x2, x3)
    df <- df[order(x1), ]
    df$match <- factor((rep("A", 12)))
    df$z <- c(1, 0,
              0, 1,
              0, 1, 0,
              0, 1, 0, 1, 1)
    ## end data set up

    x <- model.matrix(~ x1 + x2 + x3 - 1, data = df)

    d <- create_stratified_design(df$match, z = df$z)


    ## compute covariances on natural scale

    t2_cov <- t_squared_covariance(d, x)

    emp_t2 <- empirical_t2(x, d@Units, d@Count, d@Treated)
    emp_mal <- empirical_mahalanobis(x, as.matrix(d@Units), d@Count, d@Treated)

    k <- dim(emp_t2)[2]
    emp_t2_cov <- cov(t(emp_t2)) * (k - 1) / k 

    expect_equal(dim(emp_t2_cov), c(4,4))
    expect_equal(dim(t2_cov), c(4,4))

    expect_equivalent(emp_t2_cov, t2_cov)

    ## Interesting: my hypothesis was wrong. I thought since using the singular
    ## vectors was equivalent to using x for Mahalanobis distance, the
    ## distribution of T^2 would also be the same.
    ## Wrong! The only test that passes compares emp_mal and emp_u_mal
    ## Leaving this in as an interesting little finding.

    ##  xu <- svd(x)$u
    ##  u_cov <- t_squared_covariance(d, xu)
    ##  expect_equivalent(t2_cov, u_cov)

    ##  emp_u <- empirical_t2(xu, d@Units, d@Count, d@Treated)
    ##  k <- dim(emp_u)[2]
    ##  emp_u_cov <- cov(t(emp_u)) * (k - 1) / k 

    ##  emp_u_mal <- empirical_mahalanobis(xu, as.matrix(d@Units), d@Count, d@Treated)
    ##  expect_equivalent(emp_mal, emp_u_mal)

    ##  expect_equivalent(emp_u_cov, emp_t2_cov)
    ##  expect_equivalent(emp_u_cov, u_cov)
})

test_that("Multiple strata covariance calculations", {
    

    ## Set up
    ## Generate some random data
    set.seed(30303)
    n <- 12
    x1 <- rnorm(n)
    x2 <- x1 + runif(n, -1,  3)
    x3 <- sample(letters[1:3], n, replace = TRUE )
    df <- data.frame(x1, x2, x3)
    df <- df[order(x1), ]
    df$match <- factor(c(rep("A", 5),
                         rep("B", 7)))
    df$z <- c(1, 0, 0, 1, 0,
              1, 0, 0, 1, 0, 1, 1)
    ## end data set up

    ## set up the numeric covariance matrix for all the data
    x <- model.matrix(~ x1 + x2 + x3 - 1, data = df)

    ## the design using both strata
    d <- create_stratified_design(df$match, z = df$z)
    
    ## now create designs for the A and B strata
    dfa <- df[df$match == "A", ]
    dfa$match <- factor("A")
    da <- create_stratified_design(dfa$match, z = dfa$z)
    
    dfb <- df[df$match == "B", ]
    dfb$match <- factor("B")
    db <- create_stratified_design(dfb$match, z = dfb$z)

    ## generating all possible T^2 and getting cov
    ## helper function first
    covh <- function(tdist) {
        k <- dim(tdist)[2]
        cov(t(tdist)) * (k - 1) / k
    }

    emp_t2 <- empirical_t2(x, d@Units, d@Count, d@Treated)
    emp_t2_cov <- covh(emp_t2)

    emp_t2_a <- empirical_t2(x[df$match == "A", ], da@Units, da@Count, da@Treated)
    emp_t2_a_cov <- covh(emp_t2_a)

    emp_t2_b <- empirical_t2(x[df$match == "B", ], db@Units, db@Count, db@Treated)
    emp_t2_b_cov <- covh(emp_t2_b)


    ## these are the functions in Stratified.R
    t2_cov <- t_squared_covariance(d, x)
    t2_a_cov <- t_squared_covariance(da, x[df$match == "A",])
    t2_b_cov <- t_squared_covariance(db, x[df$match == "B",])

    ## basic checks for number of variables left after rotation
    expect_equal(dim(emp_t2_cov), c(4,4))
    expect_equal(dim(t2_cov), c(4,4))

    ## Now check to make sure everything matches up to the empirical results
    expect_equivalent(emp_t2_a_cov, t2_a_cov)
    expect_equivalent(emp_t2_b_cov, t2_b_cov)
    expect_equivalent(emp_t2_cov, t2_cov)


    ## Breaking down per strata covariance matrices
    emp_strata_t <- empirical_ts_by_strata(df$match, c("A" = 2, "B" = 4), x)
    emp_strata_t2_cov <- lapply(emp_strata_t, function(st) {
        covh(st^2)
    })

    scm <- strata_covariance_matrices(d, x)
    expect_equivalent(scm[1,,], emp_strata_t2_cov[[1]])
    expect_equivalent(scm[2,,], emp_strata_t2_cov[[2]])

    expect_equivalent(emp_t2_cov, emp_strata_t2_cov[[1]] + emp_strata_t2_cov[[2]])
    expect_equivalent(t2_cov, emp_strata_t2_cov[[1]] + emp_strata_t2_cov[[2]])
})
